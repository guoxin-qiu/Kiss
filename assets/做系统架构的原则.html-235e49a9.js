import{_ as n,r as i,o,c as s,a as e,b as r,d as l,e as a}from"./app-d85a60fe.js";const h={},c=a('<h1 id="做系统架构的原则" tabindex="-1"><a class="header-anchor" href="#做系统架构的原则" aria-hidden="true">#</a> 做系统架构的原则</h1><p>https://mp.weixin.qq.com/s/rx9dqv2tg1Bo0TPPc_hPzQ</p><h2 id="原则一-关注真正的收益而不是技术本身" tabindex="-1"><a class="header-anchor" href="#原则一-关注真正的收益而不是技术本身" aria-hidden="true">#</a> 原则一：关注真正的收益而不是技术本身</h2><ul><li>是否可以降低技术门槛加快整个团队的开发流程。</li><li>是否可以让整个系统可以运行的更稳定。</li><li>是否可以通过简化和自动化降低成本。 最高优化的成本是人力成本，还有时间成本和资金成本。</li></ul><h2 id="原则二-以服务和-api-为视角-而非资源和技术" tabindex="-1"><a class="header-anchor" href="#原则二-以服务和-api-为视角-而非资源和技术" aria-hidden="true">#</a> 原则二：以服务和 API 为视角，而非资源和技术</h2><p>很多技术和组件已经分不清是 Dev 还是 Ops，所以要合并。整个组织和架构的优化，已经不能通过调优单一分工或是单一组件能够有很大提升的了。其需要有一种自顶向下的，整体规划，统一设计的方式，才能做到整体的提升。而为了做到整体的提升，需要所有的人都要有一个统一的视角和目标，这几年来，我觉得这个目标就是——<strong>要站在服务和 对外 API 的视角来看问题，而不是技术和底层的角度</strong>。</p><h2 id="原则三-选择最主流和成熟的技术" tabindex="-1"><a class="header-anchor" href="#原则三-选择最主流和成熟的技术" aria-hidden="true">#</a> 原则三：选择最主流和成熟的技术</h2><p>技术选型是一件很重要的事，技术一旦选错，那会导致整个架构需要做调整，而对架构的调整从来都不是一件简单的事。</p><ul><li>尽可能使用更为成熟更为工业化的技术栈，而不是自己熟悉的技术栈。看看主流大多数公司实际在用的技术栈，会更靠谱一些。</li><li>选择全球流行的技术，而不是中国流行的技术。要看解决问题的思路和采用的技术是否具有普世性。只有普世性的技术有更强的生命力。</li><li>尽可能使用红利大的主流技术，而不是自己发明轮子，更不要魔改。这个时代是要想尽方法跟整个产业，整个技术社区融合和合作，这样才会有最大的收益。</li><li>绝大多数情况下，如无非常特殊要求，选 Java 基本是不会错的。</li></ul><h2 id="原则四-完备性会比性能更重要" tabindex="-1"><a class="header-anchor" href="#原则四-完备性会比性能更重要" aria-hidden="true">#</a> 原则四：完备性会比性能更重要</h2><ul><li>使用最科学严谨的技术模型为主，并以不严谨的模型作为补充。</li><li>性能上的东西，总是有很多解的。比起架构的完备性和扩展性来说真的不必太过担心。</li></ul><h2 id="原则五-制定并遵循服从标准、规范和最佳实践" tabindex="-1"><a class="header-anchor" href="#原则五-制定并遵循服从标准、规范和最佳实践" aria-hidden="true">#</a> 原则五：制定并遵循服从标准、规范和最佳实践</h2>',12),d=e("li",null,"服务间调用的协议标准和规范。这其中包括 Restful API 路径, HTTP 方法、状态码、标准头、自定义头等，返回数据 JSon Scheme……等。",-1),_=e("li",null,"一些命名的标准和规范。这其中包括如：用户 ID，服务名、标签名、状态名、错误码、消息、数据库……等等",-1),u=e("li",null,"日志和监控的规范。这其中包括：日志格式，监控数据，采样要求，报警……等等",-1),p=e("li",null,"配置上的规范。这其中包括：操作系统配置、中间件配置，软件包……等等",-1),f=e("li",null,"中间件使用的规范。数据库，缓存、消息队列……等等",-1),b=e("li",null,"软件和开发库版本一致。整个组织架构内，软件或开发库的版本最好每年都升一次级，然后在各团队内统一。这样会极大简化系统架构的复杂度。",-1),g={href:"https://github.com/microsoft/api-guidelines",target:"_blank",rel:"noopener noreferrer"},m={href:"https://research.google/pubs/pub36356/",target:"_blank",rel:"noopener noreferrer"},x={href:"https://zipkin.io/",target:"_blank",rel:"noopener noreferrer"},k=e("h2",{id:"原则六-重视架构扩展性和可运维性",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#原则六-重视架构扩展性和可运维性","aria-hidden":"true"},"#"),r(" 原则六：重视架构扩展性和可运维性")],-1),S=e("p",null,"如何让你的架构有更好的扩展性，可以更容易地运维，这个是比较重要的。所谓的扩展性，意味着，我可以很容易地加更多的功能，或是加入更多的系统，而所谓可运维，就是说我可以对线上的系统做任意的变更。扩展性要求的是有标准规范且不耦合的业务架构，可运维性要求的则是可控的能力，也就是一组各式各样的控制系统。",-1),v=e("li",null,"通过服务编排架构来降低服务间的耦合。比如：通过一个业务流程的专用服务，或是像 Workflow，Event Driven Architecture ， Broker，Gateway，Service Discovery 等这类的的中间件来降低服务间的依赖关系。",-1),P=e("li",null,"通过服务发现或服务网关来降低服务依赖所带来的运维复杂度。服务发现可以很好的降低相关依赖服务的运维复杂度，让你可以很轻松的上线或下线服务，或是进行服务伸缩。",-1),A={href:"https://coolshell.cn/articles/4535.html",target:"_blank",rel:"noopener noreferrer"},D={href:"https://coolshell.cn/articles/5701.html",target:"_blank",rel:"noopener noreferrer"},I={href:"https://coolshell.cn/articles/10910.html",target:"_blank",rel:"noopener noreferrer"},C={href:"https://docs.microsoft.com/en-us/azure/architecture/patterns/",target:"_blank",rel:"noopener noreferrer"},T=a('<h2 id="原则七-对控制逻辑进行全面收口" tabindex="-1"><a class="header-anchor" href="#原则七-对控制逻辑进行全面收口" aria-hidden="true">#</a> 原则七：对控制逻辑进行全面收口</h2><p>所有的程序都会有两种逻辑，一种是业务逻辑，一种是控制逻辑，业务逻辑就是完成业务的逻辑，控制逻辑是辅助，比如你用多线程，还是用分布式，是用数据库还是用文件，如何配置、部署，运维、监控，事务控制，服务发现，弹性伸缩，灰度发布，高并发，等等，等等 ……这些都是控制逻辑，跟业务逻辑没有一毛钱关系。控制逻辑的技术深度会通常会比业务逻辑要深一些，门槛也会要高一些，所以，最好要专业的程序员来负责控制逻辑的开发，统一规划统一管理，进行收口。这其中包括：</p><ul><li>流量收口。包括南北向和东西向的流量的调度，主要通过流量网关，开发框架 SDK 或 Service Mesh 这样的技术。</li><li>服务治理收口。包括：服务发现、健康检查，配置管理、事务、事件、重试、熔断、限流……主要通过开发框架 SDK – 如：Spring Cloud，或服务网格 Service Mesh 等技术。</li><li>监控数据收口。包括：日志、指标、调用链……主要通过一些标准主流的探针，再加上后台的数据清洗和数据存储来完成，最好是使用无侵入式的技术。监控的数据必须统一在一个地方进行关联，这样才会产生信息</li><li>资源调度有应用部署的收口。包括：计算、网络和存储的收口，主要是通过容器化的方案，如 k8s 来完成。</li><li>中间件的收口。包括：数据库，消息，缓存，服务发现，网关……等等。这类的收口方式一般要在企业内部统一建立一个共享的云化的中间件资源池。</li></ul><p>对此这里的原则是：</p><ul><li>你要选择容易进行业务逻辑和控制逻辑分离的技术。这里，Java 的 JVM+字节码注入+AOP 式的 Spring 开发框架，会带给你太多的优势。</li><li>你要选择可以享受“前人种树，后人乘凉”的有技术红利的技术。如：有庞大社区而且相互兼容的技术，如：Java, Docker, Ansible，HTTP，Telegraf/Collectd……</li><li>中间件你要使用可以 支持 HA 集群和多租户的技术。这里基本上所有的主流中间件都会支持 HA 集群方式的。</li></ul><h2 id="原则八-不要迁就老旧系统的技术债务" tabindex="-1"><a class="header-anchor" href="#原则八-不要迁就老旧系统的技术债务" aria-hidden="true">#</a> 原则八：不要迁就老旧系统的技术债务</h2>',6),y=e("li",null,"与其花大力气迁就技术债务，不如直接还技术债。是所谓的长痛不如短痛。",-1),z={href:"https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer",target:"_blank",rel:"noopener noreferrer"},B=e("h2",{id:"原则九-别依赖自己的经验-要基于数据和学习",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#原则九-别依赖自己的经验-要基于数据和学习","aria-hidden":"true"},"#"),r(" 原则九：别依赖自己的经验，要基于数据和学习")],-1),E=e("p",null,"如果有一天你在做技术决定的时候，开始凭自己以往的经验，那么你就已经不可能再成长了。人都是不可能通过不断重复过去而进步的，人的进步从来都是通过学习自己不知道的东西。所以，千万不要依赖于自己的经验做决定。做任何决定之前，最好花上一点时间，上网查一下相关的资料，技术博客，文章，论文等 ，同时，也看看各个公司，或是各个开源软件他们是怎么做的？然后，比较多种方案的 Pros/Cons，最终形成自己的决定，这样，才可能做出一个更好的决定。",-1),J={id:"原则十-千万小心-x-y-问题-要追问原始问题",tabindex:"-1"},V=e("a",{class:"header-anchor",href:"#原则十-千万小心-x-y-问题-要追问原始问题","aria-hidden":"true"},"#",-1),G={href:"https://coolshell.cn/articles/10804.html",target:"_blank",rel:"noopener noreferrer"},H=e("h2",{id:"原则十一-激进胜于保守-创新与使用并不冲突",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#原则十一-激进胜于保守-创新与使用并不冲突","aria-hidden":"true"},"#"),r(" 原则十一：激进胜于保守，创新与使用并不冲突")],-1),M=e("p",null,"进步永远来自于探索，探索是要付出代价的，但是收益更大。",-1);function N(O,q){const t=i("ExternalLinkIcon");return o(),s("div",null,[c,e("ul",null,[d,_,u,p,f,b,e("li",null,[r("RESTful API 的规范。写得最好的参考："),e("a",g,[r("Microsoft"),l(t)]),r("。Restful API 有一个标准和规范最大的好处就是监视可以很容易地做各种统计分析，控制系统可以很容易的做流量编排和调度。")]),e("li",null,[r("服务调用链跟踪。对于服务调用链追踪来说，基本上都是参考于 "),e("a",m,[r("Google Dapper"),l(t)]),r(" 这篇论文，目前有很多的实现，最严格的实现是 "),e("a",x,[r("Zipkin"),l(t)]),r("，这也是 Spring Cloud Sleuth 的底层实现。Zipkin 贴近 Google Dapper 论文的好处在于——无状态，快速地把 Span 发出来，不消耗服务应用侧的内存和 CPU。这意味着，监控系统宁可自己死了也不能干扰实际应用")])]),k,S,e("ul",null,[v,P,e("li",null,[r("一定要使用各种软件设计的原则。比如：像 SOLID 这样的原则（参看"),e("a",A,[r("《一些软件设计的原则》"),l(t)]),r("），IoC/DIP，SOA 或 Spring Cloud 等 架构的最佳实践（参看"),e("a",D,[r("《SteveY 对 Amazon 和 Google 平台的吐槽》"),l(t)]),r("中的 Service Interface 的那几条军规），分布式系统架构的相关实践（参看："),e("a",I,[r("《分布式系统的事务处理》"),l(t)]),r("，或微软件的 "),e("a",C,[r("《Cloud Design Patterns》"),l(t)]),r("）……等等")])]),T,e("ul",null,[y,e("li",null,[r("建设没有技术债的“新城区”，并通过“"),e("a",z,[r("防腐层"),l(t)]),r("”的架构模型，不要让技术债侵入“新城区”。")])]),B,E,e("h2",J,[V,r(" 原则十：千万小心 "),e("a",G,[r("X-Y"),l(t)]),r(" 问题，要追问原始问题")]),H,M])}const L=n(h,[["render",N],["__file","做系统架构的原则.html.vue"]]);export{L as default};
